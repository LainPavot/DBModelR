#'
#' @importFrom methods new selectMethod setRefClass is
#' @importFrom purrr map
#' @import RSQLite
NULL


#' Class ModelDefinition (and methods)
#'
#' @description This class must be used to create the models
#' used by your programs.
#' 
#'
#' @section Fields:
#' \describe{
#'
#' \item{\code{table}:}{Object of class \code{"character"}, the name of
#' the table. This field will be used to determine the name of the
#' resulting generated class}
#'
#' \item{\code{fields}:}{Object of class \code{"list"}, a named list.
#' The names are the fields of the table and the values are the SQL type
#' of the field (REAL, BOOLEAN, INTEGER, BLOB, or TEXT)}
#'
#' \item{\code{fk}:}{Object of class \code{"list"}, a simple list.
#' It contains the name of the tables that needs to be references by
#' this table.
#' Mutual references create linkage table.
#' One-way references create an fk field, named table_name_id.
#' }
#'
#' }
#' @export ModelDefinition
#' @exportClass ModelDefinition
#' @examples
#' 
#' models <- list(
#'     person=ModelDefinition(
#'         table="person",
#'         fields=list(
#'             name="TEXT",
#'             family_name="TEXT"
#'         )#, many=list("adress")
#'         ## One person possibly has multiple adress. Or none...
#'         ## "many" fields defines the creation of a linkage table (many_to_many).
#'         ## "one" fields defines a fk field enforced by a foreign key
#'         ## restriction (one_to_one)
#'         ## "many" fields mustn't be duplicated. So, "adress" must not
#'         ## reference the "person" table.
#'     ),
#'     adress=ModelDefinition(
#'         table="adress",
#'         fields=list(
#'             number="INTEGER",
#'             street="TEXT"
#'         )
#'     )
#' )
ModelDefinition <- setRefClass(
    "ModelDefinition",
    fields=c(
        table="character",
        fields="list",
        many="list",
        one="list"
    )
)

#' Class ORM (and methods)
#'
#' ORM class is the main class of the orm package.
#' This is one of the only class that should be used by programmers
#'
#' @export ORM
#' @exportClass ORM
#'
#' @examples
#' 
#' library(RSQLite)
#' 
#' models <- list(
#'     person=ModelDefinition(
#'         table="person",
#'         fields=list(
#'             name="TEXT",
#'             family_name="TEXT"
#'         )#, many=list("adress")
#'         ## One person possibly has multiple adress. Or none...
#'         ## "many" fields defines the creation of a linkage table (many_to_many).
#'         ## "one" fields defines a fk field enforced by a foreign key
#'         ## restriction (one_to_one)
#'         ## "many" fields mustn't be duplicated. So, "adress" must not
#'         ## reference the "person" table.
#'     ),
#'     adress=ModelDefinition(
#'         table="adress",
#'         fields=list(
#'             number="INTEGER",
#'             street="TEXT"
#'         )
#'     )
#' )
#' orm <- ORM("people.sqlite", model_definitions=models)
#' 
#' ## like this, we'll see the requests generated by the orm
#' print(orm$create_database())
#' ## the tables has been generated, fks and their restrictions has been
#' ## defined and linked table has been created if necessary
#' 
#' ## we've created a person who's name is Alice Smith.
#' ## Alice has been saved into the database.
#' alice <- orm$person(name="Alice", family_name="smith")$save()
#' 
#' ## Alice has been successfully added to and loaded from the database.
#' print(orm$person()$load_by(name="Alice"))
#' 
#' ## The id is 1, because it's the first person to be inserted into the
#' ## "person" table.
#' ## The orm has generated an "INSERT" query.
#' print(alice$get_id())
#' 
#' ## He's a boy, so he's changed his name to "Bob". Suits him better.
#' ## Fields must always be setted with "model$set_field_name(value)".
#' ## otherwise the orm will not see the modifications, and will not save
#' ## them in the database.
#' bob <- alice$set_name("bob")$save()
#' 
#' ## still 1. Because the orm did not add new database entry.
#' ## The orm has generated an "UPDATE" query.
#' print(bob$get_id())
#' 
#' ##### this does not work for the moment #####
#' ## prints an empty list()
#' ## no address has been assigned to him for the moment.
#' #   print(bob$get_address())
#' #   
#' #   ## let's give him a home
#' #   bob$add_adress(
#' #       ## the orm sanitizes the user's inputs and prevent sql injections.
#' #       orm$adress(number="42", street="Second street ; -- drop table person")
#' #   )
#' #   ## The orm detects that the address object assigned to bob is not saved
#' #   ## yet in the database.
#' #   ## So, the orm will register the address, and then create a link between
#' #   ## bob and the address through a linkage table.
#' #   bob$save()
#' #   
#' #   ## now Bob is happy because he has an address
#' #   ## prints: list(<adress id: 1> ...) etc.
#' #   print(bob$get_address())
#' #   
#' #   ## the street name is still somewat strange...
#' #   ## let's make it less strange
#' #   bob$get_address(
#' #       ## we select the adress with a strange name...
#' #       street="Second street ; -- drop table person"
#' #   
#' #   ## we set a more... usual name. And we save it (the address).
#' #   )$set_street("Second street")$save()
#' #   
#' #   ## never forget to disconnect when your're finished!
#' #   orm$disconnect()
#' #   
#' #   ## not to forget, there's a little trick:
#' #   ## this call orm$connect()
#' #   ## and at the end of the block, it calls orm$disconnect()
#' #   ## so you never foget to disconnect from the database.
#' #   orm$with_connection({
#' #       bob <- orm$person()$load_by(name="bob")
#' #       bob$add_adress(
#' #           ## he's has a second residence
#' #           orm$adress(number="02", street="the squirel's path")
#' #       )$save()
#' #   
#' #       ## finily he decided to live in his second house, and sold the
#' #       ## first one.
#' #       bob$delete_adress(stree="Second street")$save()
#' #   
#' #   })
#' #   ## now, you're disconnected from the database.
#' 
ORM <- setRefClass(
    "ORM",
    fields=c(
        model_definitions_="list",
        model_objects_="list",
        connected_="logical",
        connection_="SQLiteConnection",
        database_path="character",
        request_pool="list",
        execution_context="list",
        DELETE_ALL_TABLES="character",
        IF_NO_EXISTS="character",
        CREATE_TABLE_TEMPLATE="character",
        CREATE_LINKAGE_TABLE_TEMPLATE="character",
        SELECT_WHERE_TEMPLATE="character",
        INSERT_WHERE_TEMPLATE="character",
        UPDATE_WHERE_TEMPLATE="character",
        FK_CONSTRAINT_TEMPLATE="character",
        OPERATORS="list",
        LOGICAL_CONNECTORS="list"
    )
)

#' Class ModelMeta (and methods)
#'
#' @description This class is the super class of classes generated by
#' the model builder
#' 
#'
#' @section Fields:
#' \describe{
#'
#'     \item{\code{table}:}{
#'         Object of class \code{"character"}, the name of
#'         the table. This field will be used to determine the name of the
#'         resulting generated class
#'     '}
#'
#'     \item{\code{fields}:}{
#'         Object of class \code{"list"}, a named list.
#'         The names are the fields of the table and the values are the
#'         SQL type of the field (REAL, BOOLEAN, INTEGER, BLOB, or TEXT)
#'     '}
#'
#'     \item{\code{fk}:}{
#'         Object of class \code{"list"}, a simple list.
#'         It contains the name of the tables that needs to be references by
#'         this table.
#'         Mutual references create linkage table.
#'         One-way references create an fk field, named table_name_id.
#'     }
#'
#' }
ModelMeta <- setRefClass(
    "ModelMeta",
    fields=c(
        modified__="list",
        sql_model__="ModelDefinition",
        table__="character",
        orm__="ORM",
        model_name__="character",
        fields__="list",
        loaded__="logical",
        id="numeric"
    )
)
